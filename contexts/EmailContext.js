'use client'

import { createContext, useContext, useReducer, useEffect } from 'react'
import { tempMailAPI } from '@/lib/tempmail-api'
import { supabase } from '@/lib/supabase'
import toast from 'react-hot-toast'

const EmailContext = createContext({})

// Actions pour le reducer
const EMAIL_ACTIONS = {
  SET_LOADING: 'SET_LOADING',
  SET_EMAILS: 'SET_EMAILS',
  ADD_EMAIL: 'ADD_EMAIL',
  UPDATE_EMAIL: 'UPDATE_EMAIL',
  DELETE_EMAIL: 'DELETE_EMAIL',
  SET_INBOXES: 'SET_INBOXES',
  ADD_INBOX: 'ADD_INBOX',
  UPDATE_INBOX: 'UPDATE_INBOX',
  DELETE_INBOX: 'DELETE_INBOX',
  SET_SELECTED_EMAIL: 'SET_SELECTED_EMAIL',
  SET_SELECTED_INBOX: 'SET_SELECTED_INBOX',
  SET_ERROR: 'SET_ERROR',
  CLEAR_ERROR: 'CLEAR_ERROR'
}

// √âtat initial
const initialState = {
  emails: [],
  inboxes: [],
  selectedEmail: null,
  selectedInbox: null,
  loading: false,
  error: null
}

// Reducer pour g√©rer l'√©tat
function emailReducer(state, action) {
  switch (action.type) {
    case EMAIL_ACTIONS.SET_LOADING:
      return { ...state, loading: action.payload }
    
    case EMAIL_ACTIONS.SET_EMAILS:
      return { ...state, emails: action.payload, loading: false }
    
    case EMAIL_ACTIONS.ADD_EMAIL:
      return { 
        ...state, 
        emails: [action.payload, ...state.emails],
        loading: false 
      }
    
    case EMAIL_ACTIONS.UPDATE_EMAIL:
      return {
        ...state,
        emails: state.emails.map(email => 
          email.id === action.payload.id ? { ...email, ...action.payload } : email
        ),
        selectedEmail: state.selectedEmail?.id === action.payload.id 
          ? { ...state.selectedEmail, ...action.payload } 
          : state.selectedEmail
      }
    
    case EMAIL_ACTIONS.DELETE_EMAIL:
      return {
        ...state,
        emails: state.emails.filter(email => email.id !== action.payload),
        selectedEmail: state.selectedEmail?.id === action.payload ? null : state.selectedEmail
      }
    
    case EMAIL_ACTIONS.SET_INBOXES:
      return { ...state, inboxes: action.payload, loading: false }
    
    case EMAIL_ACTIONS.ADD_INBOX:
      return { 
        ...state, 
        inboxes: [action.payload, ...state.inboxes],
        loading: false 
      }
    
    case EMAIL_ACTIONS.UPDATE_INBOX:
      return {
        ...state,
        inboxes: state.inboxes.map(inbox => 
          inbox.id === action.payload.id ? { ...inbox, ...action.payload } : inbox
        ),
        selectedInbox: state.selectedInbox?.id === action.payload.id 
          ? { ...state.selectedInbox, ...action.payload } 
          : state.selectedInbox
      }
    
    case EMAIL_ACTIONS.DELETE_INBOX:
      return {
        ...state,
        inboxes: state.inboxes.filter(inbox => inbox.id !== action.payload),
        selectedInbox: state.selectedInbox?.id === action.payload ? null : state.selectedInbox
      }
    
    case EMAIL_ACTIONS.SET_SELECTED_EMAIL:
      return { ...state, selectedEmail: action.payload }
    
    case EMAIL_ACTIONS.SET_SELECTED_INBOX:
      return { ...state, selectedInbox: action.payload }
    
    case EMAIL_ACTIONS.SET_ERROR:
      return { ...state, error: action.payload, loading: false }
    
    case EMAIL_ACTIONS.CLEAR_ERROR:
      return { ...state, error: null }
    
    default:
      return state
  }
}

export const useEmail = () => {
  const context = useContext(EmailContext)
  if (!context) {
    throw new Error('useEmail must be used within an EmailProvider')
  }
  return context
}

export const EmailProvider = ({ children }) => {
  const [state, dispatch] = useReducer(emailReducer, initialState)

  // Charger les donn√©es au montage
  useEffect(() => {
    loadUserData()
  }, [])

  // Charger toutes les donn√©es
  const loadUserData = async () => {
    dispatch({ type: EMAIL_ACTIONS.SET_LOADING, payload: true })
    try {
      await Promise.all([
        loadInboxes(),
        loadEmails()
      ])
      
      // Apr√®s avoir charg√© les inboxes, r√©cup√©rer les emails de chacune
      setTimeout(() => {
        refreshAllInboxes()
      }, 1000)
    } catch (error) {
      console.error('Erreur lors du chargement des donn√©es:', error)
      dispatch({ type: EMAIL_ACTIONS.SET_ERROR, payload: error.message })
    }
  }

  // Charger les bo√Ætes de r√©ception
  const loadInboxes = async () => {
    try {
      const { data, error } = await supabase
        .from('inboxes')
        .select('*')
        .order('created_at', { ascending: false })

      if (error) throw error
      dispatch({ type: EMAIL_ACTIONS.SET_INBOXES, payload: data || [] })
    } catch (error) {
      console.error('Erreur lors du chargement des bo√Ætes:', error)
      throw error
    }
  }

  // Charger les emails
  const loadEmails = async () => {
    try {
      const { data, error } = await supabase
        .from('emails')
        .select('*')
        .order('created_at', { ascending: false })

      if (error) throw error
      dispatch({ type: EMAIL_ACTIONS.SET_EMAILS, payload: data || [] })
    } catch (error) {
      console.error('Erreur lors du chargement des emails:', error)
      throw error
    }
  }

  // Cr√©er une nouvelle bo√Æte de r√©ception temporaire
  const createInbox = async (input) => {
    try {
      dispatch({ type: EMAIL_ACTIONS.SET_LOADING, payload: true })

      // Obtenir les domaines disponibles
      const { data: domains } = await tempMailAPI.getDomains()
      if (!domains || domains.length === 0) {
        throw new Error('Aucun domaine disponible')
      }

      let email, name
      
      // V√©rifier si l'input est une adresse email compl√®te ou juste un nom
      if (input.includes('@')) {
        // C'est une adresse email compl√®te
        email = input
        const [localPart, domain] = input.split('@')
        name = localPart
        
        // V√©rifier que le domaine est support√© (les domaines de l'API peuvent avoir un @ devant)
        const normalizedDomains = domains.map(d => d.replace('@', ''))
        if (!normalizedDomains.includes(domain)) {
          throw new Error(`Le domaine "${domain}" n'est pas support√©. Domaines disponibles: ${normalizedDomains.join(', ')}`)
        }
      } else {
        // C'est juste un nom, utiliser un domaine al√©atoire
      const domain = domains[Math.floor(Math.random() * domains.length)]
        email = `${input}@${domain}`
        name = input
      }

      // Sauvegarder dans Supabase
      const { data, error } = await supabase
        .from('inboxes')
        .insert([{
          email: email,
          name: name,
          is_active: true
        }])
        .select()
        .single()

      if (error) throw error

      dispatch({ type: EMAIL_ACTIONS.ADD_INBOX, payload: data })
      toast.success(`Bo√Æte temporaire cr√©√©e: ${email}`)
      
      // R√©cup√©rer imm√©diatement les emails existants
      setTimeout(() => {
        refreshInboxEmails(data.id)
      }, 1000) // D√©lai de 1 seconde pour laisser le temps √† l'API de traiter
      
      return data
    } catch (error) {
      console.error('Erreur lors de la cr√©ation de la bo√Æte:', error)
      dispatch({ type: EMAIL_ACTIONS.SET_ERROR, payload: error.message })
      toast.error('Erreur lors de la cr√©ation de la bo√Æte temporaire')
      throw error
    }
  }

  // Actualiser les emails d'une bo√Æte
  const refreshInboxEmails = async (inboxId) => {
    try {
      console.log('üîÑ Actualisation des emails pour inbox ID:', inboxId)
      const inbox = state.inboxes.find(i => i.id === inboxId)
      if (!inbox) {
        console.log('‚ùå Inbox non trouv√©e:', inboxId)
        return
      }

      console.log('üìÆ Inbox trouv√©e:', inbox.email)

      // R√©cup√©rer les emails depuis l'API Temp-Mail
      const { data: tempEmails, error } = await tempMailAPI.getEmails(inbox.email)
      console.log('üìß Emails r√©cup√©r√©s:', tempEmails)
      
      if (error) {
        console.error('‚ùå Erreur API:', error)
        throw new Error(error)
      }

      // V√©rifier si l'API retourne une erreur "pas d'emails"
      if (tempEmails && tempEmails.error && tempEmails.error.includes('no emails')) {
        console.log('üì≠ Aucun email trouv√© pour cette bo√Æte')
        toast('Aucun email trouv√©')
        return
      }

      if (!tempEmails || !Array.isArray(tempEmails) || tempEmails.length === 0) {
        console.log('üì≠ Aucun email trouv√© pour cette bo√Æte')
        toast('Aucun nouvel email')
        return
      }

      let newEmailsCount = 0

      // Sauvegarder les nouveaux emails dans Supabase
      for (const tempEmail of tempEmails) {
        console.log('üì® Traitement email:', tempEmail)
        const emailExists = state.emails.some(e => e.external_id === tempEmail.mail_id)
        
        if (!emailExists) {
          console.log('‚ú® Nouvel email trouv√©:', tempEmail.mail_subject || tempEmail.subject)
          console.log('üîç Structure compl√®te de l\'email:', tempEmail)
          
          // Extraire les bonnes donn√©es selon la structure de l'API
          const emailData = {
            inbox_id: inboxId,
            external_id: tempEmail.mail_id || tempEmail.id,
            from_email: tempEmail.mail_from || tempEmail.from || 'Exp√©diteur inconnu',
            to_email: tempEmail.mail_to || tempEmail.to || inbox.email || 'Destinataire inconnu',
            subject: tempEmail.mail_subject || tempEmail.subject || '(Aucun sujet)',
            content: tempEmail.mail_text_only || tempEmail.mail_html || tempEmail.text || tempEmail.html || tempEmail.body || '',
            received_at: tempEmail.mail_timestamp 
              ? new Date(tempEmail.mail_timestamp * 1000).toISOString()
              : tempEmail.createdAt 
              ? new Date(tempEmail.createdAt).toISOString()
              : new Date().toISOString(),
            is_read: false
          }
          
          console.log('üìù Donn√©es √† ins√©rer:', emailData)
          
          const { data, error: insertError } = await supabase
            .from('emails')
            .insert([emailData])
            .select()
            .single()

          if (!insertError && data) {
            dispatch({ type: EMAIL_ACTIONS.ADD_EMAIL, payload: data })
            newEmailsCount++
            console.log('‚úÖ Email sauvegard√©:', data.subject)
          } else {
            console.error('‚ùå Erreur sauvegarde:', insertError)
          }
        }
      }

      if (newEmailsCount > 0) {
        toast.success(`${newEmailsCount} nouvel(s) email(s) re√ßu(s)`)
      } else {
        toast('Emails actualis√©s - aucun nouveau')
      }
    } catch (error) {
      console.error('‚ùå Erreur lors de l\'actualisation:', error)
      toast.error(`Erreur: ${error.message}`)
    }
  }

  // Marquer un email comme lu
  const markEmailAsRead = async (emailId) => {
    try {
      const { error } = await supabase
        .from('emails')
        .update({ is_read: true })
        .eq('id', emailId)

      if (error) throw error

      dispatch({ 
        type: EMAIL_ACTIONS.UPDATE_EMAIL, 
        payload: { id: emailId, is_read: true } 
      })
    } catch (error) {
      console.error('Erreur lors du marquage comme lu:', error)
    }
  }

  // Supprimer une bo√Æte de r√©ception
  const deleteInbox = async (inboxId) => {
    try {
      const { error } = await supabase
        .from('inboxes')
        .delete()
        .eq('id', inboxId)

      if (error) throw error

      dispatch({ type: EMAIL_ACTIONS.DELETE_INBOX, payload: inboxId })
      toast.success('Bo√Æte supprim√©e')
    } catch (error) {
      console.error('Erreur lors de la suppression:', error)
      toast.error('Erreur lors de la suppression')
    }
  }

  // Actualiser les emails de toutes les bo√Ætes
  const refreshAllInboxes = async () => {
    console.log('üîÑ Actualisation de toutes les bo√Ætes')
    const activeInboxes = state.inboxes.filter(inbox => inbox.is_active)
    console.log('üìÆ Bo√Ætes actives:', activeInboxes.length)
    
    for (const inbox of activeInboxes) {
      console.log('üîÑ Traitement de la bo√Æte:', inbox.email)
      await refreshInboxEmails(inbox.id)
      // Petite pause entre chaque requ√™te pour √©viter le rate limiting
      await new Promise(resolve => setTimeout(resolve, 500))
    }
  }

  const value = {
    ...state,
    // Actions
    createInbox,
    refreshInboxEmails,
    refreshAllInboxes,
    markEmailAsRead,
    deleteInbox,
    loadUserData,
    // Setters
    setSelectedEmail: (email) => dispatch({ type: EMAIL_ACTIONS.SET_SELECTED_EMAIL, payload: email }),
    setSelectedInbox: (inbox) => dispatch({ type: EMAIL_ACTIONS.SET_SELECTED_INBOX, payload: inbox }),
    clearError: () => dispatch({ type: EMAIL_ACTIONS.CLEAR_ERROR })
  }

  return (
    <EmailContext.Provider value={value}>
      {children}
    </EmailContext.Provider>
  )
} 